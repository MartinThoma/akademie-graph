<!DOCTYPE html>

<html>

<head>
    <meta http-equiv="content-type" content="text/html; charset=UTF8">
    <title>Wer kennt wen? – Neubeuern 2015 Edition</title>

    <!-- Load the vis library and CSS via their CDN.-->
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.7.0/vis.min.js"></script>
    <link type="text/css" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.7.0/vis.min.css">

    <!-- Load the data, i.e. the nodes and edges for the graph-->
    <script src="nodes-and-edges.js"></script>

    <!-- Some CSS, should probably be put into separate file -->
    <style type="text/css">
        #graph {
            width: 800px;
            height: 800px;
            border: 1px solid lightgray;
            background: #EFEEED;
        }
    </style>
</head>


<body>

<h2>Wer kennt wen? – Neubeuern 2015 Edition</h2>
<div style="width:800px; font-size:14px;">
	Lorem Ipsum sit dolor amet...
	<br><br>
</div>


<div id="graph"></div>

<script type="text/javascript">
var network;
var allNodes;
var highlightActive = false;

var nodesDataset = new vis.DataSet(nodes);
var edgesDataset = new vis.DataSet(edges);

//edgesDataset.update({id: 1, color: {color: 'red'}});

function redrawAll() {
    var container = document.getElementById('graph');
    var options = {
        nodes: {
            shape: 'dot',
            scaling: {
                min: 10,
                max: 30,
                label: {
                    min: 8,
                    max: 30,
                    drawThreshold: 12,
                    maxVisible: 20
                }
            },
            font: {
                size: 12,
                face: 'Roboto Slab',
                color: '#444444'
            },
            color: {
                highlight: {
                    background: 'red',
                    border: 'red'
                }
            }
        },
        edges: {
            width: 1,
            color: {
                inherit: false
            },
            smooth: {
                type: 'continuous'
            }
        },
        physics: {
            enabled: true,
            barnesHut: {
                gravitationalConstant: -1000,
                centralGravity: 0.3,
                springLength: 1000,
                springConstant: 0.04,
                damping: 0.09,
                avoidOverlap: 0
            },
            forceAtlas2Based: {
                gravitationalConstant: -50,
                centralGravity: 0.01,
                springConstant: 0.08,
                springLength: 100,
                damping: 0.4,
                avoidOverlap: 0
            },
            repulsion: {
                centralGravity: 0.2,
                springLength: 200,
                springConstant: 0.05,
                nodeDistance: 100,
                damping: 0.09
            },
            hierarchicalRepulsion: {
                centralGravity: 0.0,
                springLength: 100,
                springConstant: 0.01,
                nodeDistance: 120,
                damping: 0.09
            },
            maxVelocity: 50,
            minVelocity: 0.1,
            solver: 'barnesHut',
            stabilization: {
                enabled: true,
                iterations: 1000,
                updateInterval: 100,
                onlyDynamicEdges: false,
                fit: true
            },
            timestep: 0.5
        },
        interaction: {
            tooltipDelay: 200,
            hideEdgesOnDrag: true
        },
    };
    var data = {
            nodes: nodesDataset,
            edges: edgesDataset
        }

    // get a JSON object
    allNodes = nodesDataset.get({
        returnType: "Object"
    });
    allEdges = edgesDataset.get({
        returnType: "Object"
    });

    network = new vis.Network(container, data, options);
    network.on("click", neighbourhoodHighlight);
}

function GetEdgeColor(edgeId) {
    return allNodes[allEdges[edgeId].from].color;
}



function GetIncomingEdges(selectedNode, all_edges) {
    var connectedNodes = network.getConnectedNodes(selectedNode);
    var incomingEdges = [];

    // Loop over all connected Nodes
    for (var nodeId in connectedNodes) {

        // Loop over all edges to find the edge between selected and currect
        for (edge in all_edges) {
            // If there is and edge that goes from the current to the selected
            // we have found and incoming node!
            if ((all_edges[edge].from == connectedNodes[nodeId] &&
                    all_edges[edge].to == parseInt(selectedNode)) ||
                (all_edges[edge].from == parseInt(selectedNode) &&
                    all_edges[edge].to == connectedNodes[nodeId] &&
                    all_edges[edge].arrows == undefined)) {
                incomingEdges.push(edge);
            }
        }
    }

    return incomingEdges;
}



function GetIncomingNodes(selectedNode, all_edges) {

    var connectedNodes = network.getConnectedNodes(selectedNode);
    var incomingNodes = [];

    // Loop over all connected Nodes
    for (var nodeId in connectedNodes) {

        // Loop over all edges to find the edge between selected and currect
        for (edge in all_edges) {
            // If there is and edge that goes from the current to the selected
            // we have found and incoming node!
            if ((all_edges[edge].from == connectedNodes[nodeId] &&
                    all_edges[edge].to == parseInt(selectedNode)) ||
                (all_edges[edge].from == parseInt(selectedNode) &&
                    all_edges[edge].to == connectedNodes[nodeId] &&
                    all_edges[edge].arrows == undefined)) {
                //console.log('Edge ', edge, ' goes from ', all_edges[edge].from, 'to', all_edges[edge].to)
                incomingNodes.push(connectedNodes[nodeId]);
                break;
            }
        }
    }

    return incomingNodes;
}



function neighbourhoodHighlight(params) {
    // if something is selected:
    if (params.nodes.length > 0) {
        highlightActive = true;
        var i, j;
        var selectedNode = params.nodes[0];
        var degrees = 1;

        // Make all Nodes and Edges gray
        for (var nodeId in allNodes) {
            if (nodeId == selectedNode) {
                continue;
            }
            allNodes[nodeId].color = 'rgba(200,200,200,0.5)';
            if (allNodes[nodeId].hiddenLabel === undefined) {
                allNodes[nodeId].hiddenLabel = allNodes[nodeId].label;
                allNodes[nodeId].label = undefined;
            }
        }
        for (var edgeId in allEdges) {
            allEdges[edgeId].color = 'rgba(200,200,200,0.5)';
        }

        var incomingNodes = GetIncomingNodes(selectedNode, edges);
        var incomingEdges = GetIncomingEdges(selectedNode, edges);

        // The selected node itself gets its color and label back
        var border = allNodes[selectedNode].original_color.border
        var background = allNodes[selectedNode].original_color.background
        allNodes[selectedNode].color = {background: background, border: border, highlight: {background: background, border: border}};
        if (allNodes[selectedNode].hiddenLabel !== undefined) {
                     allNodes[selectedNode].label = allNodes[selectedNode].hiddenLabel;
                     allNodes[selectedNode].hiddenLabel = undefined;
        }

        // All incoming Nodes get their color and labels back
        for (node in incomingNodes) {
            allNodes[incomingNodes[node]].color = allNodes[incomingNodes[node]].original_color;
            if (allNodes[incomingNodes[node]].hiddenLabel !== undefined) {
                         allNodes[incomingNodes[node]].label = allNodes[incomingNodes[node]].hiddenLabel;
                         allNodes[incomingNodes[node]].hiddenLabel = undefined;
            }
        }
        
        // All incoming Edges get their color back
        for (edge in incomingEdges) {
            allEdges[incomingEdges[edge]].color = allEdges[incomingEdges[edge]].original_color;
        }

    } else if (highlightActive === true) {
        // reset all nodes
        for (node in allNodes) {
            allNodes[node].color = allNodes[node].original_color;
            if (allNodes[node].hiddenLabel !== undefined) {
                allNodes[node].label = allNodes[node].hiddenLabel;
                allNodes[node].hiddenLabel = undefined;
            }
        }
        for (edge in allEdges) {
            allEdges[edge].color = allEdges[edge].original_color;
        }
        highlightActive = false
    }

    // transform the object into an array
    var updateArray = [];
    for (nodeId in allNodes) {
        if (allNodes.hasOwnProperty(nodeId)) {
            updateArray.push(allNodes[nodeId]);
        }
    }
    nodesDataset.update(updateArray);
    
    var updateArray = [];
    for (edgeId in allEdges) {
        if (allEdges.hasOwnProperty(edgeId)) {
            updateArray.push(allEdges[edgeId]);
        }
    }
    edgesDataset.update(updateArray);
}

redrawAll()
</script>

</body>

</html>
